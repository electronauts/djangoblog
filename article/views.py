# -*- coding: utf-8 -*-
from django.shortcuts import render
# ----ччч - я тут самый прокаченный дать номер пйдра----
# kill me this is mac - drop the base!!!
# Для "basic_one"
# Чтобы мы могли возвратить response - Нам нужно из django импортировать HttpResponse
from django.http.response import HttpResponse

# Импортируем несколько важных для нас классов
from django.template.loader import get_template 
from django.template import Context 
# Мы импортировали два класса: get_template и Context
# get_template - отвечает за получение шаблона
# Context отвечает за хранение тех переменных, которые будут потом отправлены в шаблон


# Это для третей функции импорты
# render в ответ сразу
from django.shortcuts  import render_to_response 


# ------- 5 Занятие -----------
from article.models import Article, Comments


#  Функция 'basic_one'.
# В качестве параметра функция должна получать request (некий запрос), 
# делает некие действия и должна вернуть response - ответ.
def basic_one(request):
    view = "basic_one"
# Здесь мы имитируем html-code
# % - знак означает что мы должны его заменить строковым значением описанным после кавычек
    html = "<html><body>This is %s view fuckyeah!!! lol</html></body>" % view
    return HttpResponse(html)


def template_two(request):
# 1. Создали переменную	
    view = "template_two"
# 2. Получили файл шаблона. Кладем в переменную t наш шаблон.
    t = get_template('myview.html')

# У нас в представлении есть переменная "name" 

###### !!! Context отвечает за хранение переменных,
###### которые будут потом отображаться в представлении. 

# 3. Создали контекст представления внутри которого отправили нашу переменную name со значением view 
# Context({'name':view})

###### Вставляем нашу переменную в виде словаря как ключ словаря
###### Как значение словаря мы добавляем view - template_two


# ===========Мы формируем html-code. Для этого мы используем "render"==========
# 4. t.render(...) - объединили текст шаблона с переменной т.е. создали полнеценнй html-код
   
    html = t.render(Context({'name':view})) 
# Эта строка сгенерирует наш финальный html-код.
# Но теперь его надо отправить обратно в браузер 
# 5. Вернули этот html код внутри нашего HttpResponse объекта
    return HttpResponse(html)

# Второй вариант несколько сложен, нам нужно написать целых 4 строки для простейшего действия.
# Разработчики Django создали упращенный вариант

# самый простой и эффективный способ отправки информации пользователю:
def template_three_simple(request):
    view = "template_thee"
# В какой view отправляем данные 
# Потом какие именно мы собираемся отправлять данные
    return render_to_response('myview.html', {'name': view})

#----------------------------------Занятие 5------------------------
# Articles выводит всю стену в html-файл articles.html.
# Выводит что - какие переменные мы отдаем. мы отдаем всю таблицу 'articles' т.е. полностью все что хранится в этой таблице и будет это все хранится в переменной 'articles', но мы используем не простую переменную, а получаем информацию из баз данных. Чтобы получить оттуда информацию нам необходимо импортировать наши модели (см. import к пятому занятию). 
# В данном случае нас интересуют толькок все статьи.


def articles(request):
    return render_to_response('articles.html', {'articles': Article.objects.all()})

# article - вторая функция, отвечающая за вывод только одной статьи, но полностью вместе с комментариями.
# Интересный момент. Мы используем не только request, Но Нам нужно понять, а какую же статью мы выводим. Статьи имеют уникальный признак id. Именно по этому признаку мы будем выяснять, какую статью  мы сейчас собираемеся вывести но для этого нам необходимо получить этот id из браузера. По умолчанию поставлю id = 1 на тот случай, если человек не ввел никакого id, то чтобы у нас не вылазила ошибка по умолчанию будет выводиться статья №1. Самая старая получается в нашем случае.

def article(request, article_id=1):
    return render_to_response('article.html', {'article': Article.objects.get(id=article_id), 'comments': Comments.objects.filter(comments_article_id=article_id)})

# Переменная на этот раз будет называться article, будет брать Article.objects.get и в качестве параметра id=article_id (Есть колонка в таблице в article - id, равная article_id равная тому, что передал броузер) у нас как чувак показывал есть колонка в таблице article_id

# Но есть одна важная фишка. Нам необходимо получить только те комментарии, которые ассоциированны с вот этой статьей (id) данной статьей.
# Нас интересует колонка comments_article_id это колонка, которая ассоциирут наши комментарии с нашими статьями
# мы используем ф-ю fileter, она огр. нашу выбурку filter(comments_article_id=article_id)

# Мы создали переменные: artice, comments
# в article мы забили только одну запись только одну запись из таблицы articles Article.oblejects.get (article_id - передан нам из браузера)
# Мы создали переменную comments, в которую сохраним все комментарии у которых comments_article_id=article_id


